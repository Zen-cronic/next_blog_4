---
title: 'How to learn best? Create'
date: '2023-09-04'
subtitle: Why building projects is the best way to learn
---

The best way to learn is by doing.

Throughout my programming journey, this has been a motto I’ve clutched onto.

Nothing beats real experience.

Not reading books.

Not watching YouTube.

Not thinking about doing something.

At first, it was my goal to code and host a personal blog website on my own domain. But I didn’t want to burn the candle at both ends.

So, I set aside the coding part for later and focused on putting out written content. After a while, I redirected my attention to building the blog website from scratch. You can go view it at www.kaungzinhein.me!

Through this personal project, I’ve learned (and still learning):

1. CSS
2. Deploying a website
3. The basics of nextjs 13 (e.g., routing)
4. Implementing search functionality in nextjs (and react)

Before taking on the project, I was just toying around with nextjs project tutorials. Despite them being projects — which are ultimately better than random textbook exercises — it didn’t feel like they carried much significance.

And that’s simply because these projects lacked a personal goal behind them.

Without a personal touch to the source of motivation, any activity can feel impractical.
That’s how the idea came to mind. Arose from the combination of having a blog platform (to deliver long-form content) and aspiring to design web applications, is the blog project.

I started out looking for resources — to replicate and apply into my own website.

Then I discovered that even a project as seemingly simple as this requires many pieces to be put together. The pieces were as follows:

1. CSS styling — though not a full-fledged landing page, I made a goal to make the website look decent at least. This is a laziness I had to confront– I’ve always had a personal backlash against spending time on web design, leaning more towards backend development.

2. Comfort with nextjs — how the framework works and the common best practices.
After studying other successful blog websites, I decided to include a search bar functionality that would help filter out my articles. Through trying to figure out how to implement this in nextjs, I also came up with implementations in the react backend — which I continue to use in other projects.

At the same time, the non-programming technical pieces were just as challenging:

1. Hosting my blog app
2. Registering a personal domain name
3. The problem-solving it took for these steps was unexpected, which stretched my comfort zone as a programmer who’s used to solving code-related issues but not non-code technical issues.

Another main takeaway from this experience is that “have a need to learn something”.

Frankly, I’ve put off “CSS” for a while (more frankly, ever since I started learning web development). I was always reluctant to let it take up space in my self-study curriculum for fear that it would leave less room for other more critical skills (e.g., state management, backend APIs).

But when I took up this project, I found a need for CSS. Therefore, I pursued it.

This is the most crucial lesson to glean from the principles of PBL.

When confronted with a problem to solve or a project to build, it’s natural to learn and zero in on the necessary skills.

Each skill/topic is a missing piece to the puzzle you’re trying to solve.

On the other hand, most curriculums are designed with the aim of teaching as many topics in as little time as possible. And often these topics are unrelated to one another.

Here, each topic is a missing piece from many different puzzles, and you never get to finish a single puzzle in its entirety.

No wonder it feels like you’re going through the topics rather than challenging and rewarding.

Without a reason behind why you’re learning what you’re learning, why bother?

Projects are a great way to infuse a personal reason.
Let’s not stop here. There are even more benefits to the PBL approach.

Reusability.
For example, the algorithm for the search function on my blog is implemented in other projects as well, with some variations.

What you’ve learned from or discovered during building a project can be applied in future projects. This gives you opportunities to improve the performance of the reused feature/skill by applying it in other contexts.

This is repetition.

Repetition with feedback over time leads to mastery — principle of deliberate practice.

This is how I’m shaping my software engineering portfolio as a self-taught programmer — diverting the bulk of my time and effort into building projects that are applicable in real situations.

· I set out to program a blog website to host my articles
· Projects with a goal make you learn what’s relevant and necessary
· Projects are reusable

Happy building projects!